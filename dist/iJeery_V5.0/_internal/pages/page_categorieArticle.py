import customtkinter as ctk
import tkinter as tk
from tkinter import messagebox, filedialog, ttk
import psycopg2
import json
import os
import sys
from resource_utils import get_config_path, safe_file_read


class PageCategorieArticle(ctk.CTkFrame):
    def __init__(self, parent):
        super().__init__(parent)
        
        # 1. Connexion et Initialisation
        self.conn = self.connect_db()
        if self.conn:
            self.cursor = self.conn.cursor()
            self.initialiser_table()
        else:
            # Si la connexion échoue, on arrête l'init ici
            return

        # 2. Éléments de l'Interface (UI)
        self.setup_ui()
        
        # 3. Chargement initial des données
        self.charger_categoriearticle()

    def connect_db(self):
        try:
            if not os.path.exists(get_config_path('config.json')):
                 messagebox.showerror("Erreur", "Fichier config.json manquant.")
                 return None
                 
            with open(get_config_path('config.json')) as f:
                config = json.load(f)
                db_config = config['database']

            conn = psycopg2.connect(
                host=db_config['host'],
                user=db_config['user'],
                password=db_config['password'],
                database=db_config['database'],
                port=db_config['port']  
            )
            return conn
        except Exception as err:
            messagebox.showerror("Erreur de connexion", f"Détails : {err}")
            return None

    def initialiser_table(self):
        try:
            # Modification pour utiliser IDENTITY (plus moderne et robuste que SERIAL)
            self.cursor.execute("""
                CREATE TABLE IF NOT EXISTS tb_categoriearticle (
                    idca INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
                    designationcat VARCHAR(75)
                )
            """)
            self.conn.commit()
            
            # --- AJOUT DE LA SYNCHRONISATION AUTOMATIQUE ---
            # Cela recalera le compteur à chaque démarrage au cas où des IDs auraient été forcés
            self.cursor.execute("""
                SELECT setval(pg_get_serial_sequence('tb_categoriearticle', 'idca'), 
                              COALESCE((SELECT MAX(idca) FROM tb_categoriearticle), 0) + 1, 
                              false);
            """)
            self.conn.commit()
            
        except psycopg2.Error as err:
            messagebox.showerror("Erreur SQL", f"Erreur table : {err}")

    def setup_ui(self):
        # Configuration des colonnes de la grille
        self.grid_columnconfigure(1, weight=1)

        # Formulaire
        ctk.CTkLabel(self, text="Désignation Catégorie:").grid(row=0, column=0, padx=10, pady=10, sticky="w")
        self.entry_designationcat = ctk.CTkEntry(self)
        self.entry_designationcat.grid(row=0, column=1, padx=10, pady=10, sticky="ew")

        # Conteneur Boutons
        btn_frame = ctk.CTkFrame(self, fg_color="transparent")
        btn_frame.grid(row=2, column=0, columnspan=2, pady=10)

        self.save_button = ctk.CTkButton(btn_frame, text="Enregistrer", fg_color="#2ecc71", hover_color="#27ae60", command=self.enregistrer)
        self.save_button.pack(side="left", padx=5)

        self.modify_button = ctk.CTkButton(btn_frame, text="Modifier", fg_color="#3498db", hover_color="#2980b9", command=self.modifier)
        self.modify_button.pack(side="left", padx=5)

        self.delete_button = ctk.CTkButton(btn_frame, text="Supprimer", fg_color="#e74c3c", hover_color="#c0392b", command=self.supprimer)
        self.delete_button.pack(side="left", padx=5)

        self.clear_button = ctk.CTkButton(btn_frame, text="Vider", command=self.vider)
        self.clear_button.pack(side="left", padx=5)

        # Treeview
        self.tree_container = ctk.CTkFrame(self)
        self.tree_container.grid(row=5, column=0, columnspan=2, padx=10, pady=10, sticky="nsew")
        self.grid_rowconfigure(5, weight=1)

        columns = ("idca", "designationcat")
        self.treeview = ttk.Treeview(self.tree_container, columns=columns, show='headings')
        
        self.treeview.heading("idca", text="ID")
        self.treeview.column("idca", width=50, anchor="center")
        self.treeview.heading("designationcat", text="Désignation")
        self.treeview.column("designationcat", width=250, anchor="w")
        
        self.treeview.pack(expand=True, fill="both")
        self.treeview.bind("<<TreeviewSelect>>", self.remplir_champs)

    # --- MÉTHODES LOGIQUES (Inchangées mais vérifiées) ---

    def charger_categoriearticle(self):
        for i in self.treeview.get_children():
            self.treeview.delete(i)
        try:
            self.cursor.execute("SELECT idca, designationcat FROM tb_categoriearticle ORDER BY idca")
            for row in self.cursor.fetchall():
                self.treeview.insert('', 'end', values=row)
        except Exception as e:
            print(f"Erreur de chargement: {e}")

    def enregistrer(self):
        designation = self.entry_designationcat.get().strip()
        if not designation:
            return
        try:
            self.cursor.execute("INSERT INTO tb_categoriearticle (designationcat) VALUES (%s)", (designation,))
            self.conn.commit()
            self.charger_categoriearticle()
            self.vider()
            messagebox.showinfo("Succès", "Enregistré !")
        except Exception as e:
            messagebox.showerror("Erreur", str(e))

    def modifier(self):
        selected = self.treeview.selection()
        if not selected: return
        idca = self.treeview.item(selected[0])['values'][0]
        designation = self.entry_designationcat.get().strip()
        try:
            self.cursor.execute("UPDATE tb_categoriearticle SET designationcat=%s WHERE idca=%s", (designation, idca))
            self.conn.commit()
            self.charger_categoriearticle()
            self.vider()
        except Exception as e:
            messagebox.showerror("Erreur", str(e))

    def supprimer(self):
        selected = self.treeview.selection()
        if not selected: return
        if messagebox.askyesno("Confirmation", "Supprimer cette catégorie ?"):
            idca = self.treeview.item(selected[0])['values'][0]
            self.cursor.execute("DELETE FROM tb_categoriearticle WHERE idca=%s", (idca,))
            self.conn.commit()
            self.charger_categoriearticle()
            self.vider()

    def remplir_champs(self, event):
        selected = self.treeview.selection()
        if selected:
            values = self.treeview.item(selected[0])['values']
            self.entry_designationcat.delete(0, tk.END)
            self.entry_designationcat.insert(0, values[1])

    def vider(self):
        self.entry_designationcat.delete(0, tk.END)
        self.treeview.selection_remove(self.treeview.selection())

if __name__ == "__main__":
    app = ctk.CTk()
    app.title("Gestion Catégories")
    app.geometry("600x500")
    page = PageCategorieArticle(app)
    page.pack(fill="both", expand=True, padx=20, pady=20)
    app.mainloop()